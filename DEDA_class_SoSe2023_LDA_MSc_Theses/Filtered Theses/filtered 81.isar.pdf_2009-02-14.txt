exchange rate dependence use copula master thesis submit prof dr wolfgang ardle institute statistic econometrics case center apply statistic economics universit zu alexandru isar partial fulfillment requirement degree master science economics february  declaration authorship hereby confirm author master thesis independently without use indicate source passage literally general matter take publication source marked march alexandru isar  acknowledgment would like thank professor dr wolfgang ha rdle opportunity grateful patience support concern guidance grateful dr enzo giacomini ongoing support thank enough would like thank girlfriend irina ever side espe cially difficult endeavor today would like thank parent past nearly year well friend still though grateful experience able gather work ing european central bank friend mentor joan paredes wim haine han olsson dieden heinz christian name thank program help would like acknowledge valentina vulcanov last definitely least would like thank prof dr med neuhaus dr med kalmuk expertise care  content introduction methodology different copula dependence copula parameter fitting data computational challenge dataset data treatment result conclusion code content list standard deviation huf skk exchange rate return day window log return exchange rate versus usd marginal distribution estimate degree freedom copula return usd eur gbp jpy sgd nok chf actual return treat data treat data refers equation time dependent variance estimate equation marginal distribution degree freedom copula degree freedom transform covariance matrix return scatter plot list list eastern european country experience peg eastern european country economic development quasi correlation matrix element average standard de viation list chapter introduction univariate method analysis often use describe evo lution economic variable non normal behavior variable observe far back mill yet characteristic assume away economic analysis empirical observation may inconvenient fact also somewhat inconsequential analysis con cerned middle distribution rather extreme due fact much economic analysis indeed concerned observation prediction expect value certain indicator deviation standard normal model may impact conclusion analysis hand risk measurement concerned occurrence unlikely event definition implies particular attention paid functional form univariate multivariate distri butions variable investigation conventionally industry risk measurement conduct use multi normal distribution see morgan reuters group empirical result show however certain inconsistency assumption normally distribute risk factor amongst thing assumption implies follow contradiction stylize fact constant volatility point giacomini ha rdle gia comini ha rdle chapter introduction symmetrical distribution around mean discuss embrechts dia thinner tail empirical evidence point tail dependence main issue mention model come fact standard tool use financial institution evaluate mar ket risk expose consequently lead sub optimal result volatility imply standard model indeed less one observe empirically furthermore one enters period high volatil ity standard model underestimate standard deviation thus lead underestimation risk asymmetry distribution variable mean one side left side indicate negative return heav ier standard symmetrical distribution model may lead underestimate risk precisely may understate area left hand side probability distribution function look multivariate distribution standard model implies correlation extreme put plainly men extreme return correlate standard model whereas empirical observation odds point point patton explain later thesis standard normal model implies tail dependence go one move extreme value involve variable empirical observation show existence correlation extreme also point fact joint distribution asymmetrical allow correlate negative return positive one number method well suit analyze risk factor standard tool one method copula perhaps conceptually best think copula function determine relationship random variable precisely link marginal joint cumulative distribution function thesis aim analyze relationship return eign exchange position particular attention eastern european cur rencies exchange rate vi vi euro second third chapter outline methodology use reason choose method ology estimation process respectively fourth chapter dedicate data economic context computational challenge fifth chapter dedicate result whereas conclusion take chapter six age use include matlab obviously latex statistical device use analysis copula lengthy code code available inspection chapter introduction chapter methodology statistical process interest movement daily return due hold particular asset return define return time price time deal portfolio many asset price return portfolio may express vector weight asset portfolio commonly however log return use log log later form return approximation former one must careful though aggregate time may produce inconsistency log turn nevertheless use analysis come look return process one immediately identifies non constant volatility exemplify volatility return huf skk exchange rate vi vi usd pas period high low volatility order analyze relationship two variable one must first bring common ground implies adjust average also homogenize variance chapter methodology standard deviation huf skk exchange rate return day window since focus thesis exploration joint behavior vari ables rather homogenization variance go great detail leave explanation particular method later chapter subsequently one need move univariate exploration multivariate context previously mention number method one may use describe joint behavior financial variable general return se ries particular one method call copula order well understand construct one may wish look theorem underlie function copula call sklar theorem outline theorem let dimensional cdf margin exists copula rd continuous unique basically every joint cdf one think exists correspond copula powerful result implies joint density different copula dependence express combination marginal distribution lationship function copula one model many kind dependence one also model inde pendence use copula recall two independent variable understandable product copula also refer inde pendence copula show equation variety copula nature dependency range none complex follow section give overview nature dependence model copula suitable copula chosen base ability model behavior consistent stylize fact basis theory empirical work perform present later thesis different copula dependence start give specific example copula necessary intro duce concept dependence see area extreme value standard model fail might useful investigate depen dence tail distribution definition give two random variable respective marginal cdf low tail dependence coefficient exists define limp upper tail dependence define way use basic prob ability theory definition copula limit express nelsen chapter methodology use opital rule one get expression limit may eval uate finite number value naturally depends functional form assume copula say copula low tail de pendence dependence useful measure dependence variable tail expect copula function rather margin dependence identify course due fact dependence express margin see later however copula tail dependence parameter equal zero important property keep mind especially apply ory model extreme value one copula lack tail dependence gaussian copula class im portant due lack tail dependence also due fact ifm inference margin mle estimator coincide case margin also gaussian mention giacomini importance fact lie mle precise estima tor ifm often ifm much less computationally intensive know particular case two estimator coincide one may use ifm estimate copula parameter gain compute time definition cgauss dx dx joint normal pdf see bivariate case relationship depends correlation per paul embrechts mcneil lim building paul embrechts mcneil show gaussian copula inevitably see copula model certain type dependence financial statistic behavior contradicts certain stylize fact point introduction thesis one may imagine instance case market crash return take highly negative value event could different copula dependence easily simulated lack dependence noteworthy limit evaluates expres sion evaluates thus dependence exists one correlation value since copula relationship variable margin result course hold regardless margin use another class copula copula family copula exhibit tail dependence converge gaussian one parameter namely degree freedom go infinity definition ct dx dx multivariate pdf coefficient matrix quantile function inverse univariate cdf two clarification perhaps necessary firstly respect function noteworthy give definition region behavior non standard namely function one many positive real number reach minimum math world com one one function thereafter implication property one rest assure crease multivariate case course behaves another clarification pertains margin versus copula degree freedom copula ct use conjunction marginal distribution yield multivariate distribution nevertheless possible use whatever margin one wish therefore possible margin different additional parameter copula degree freedom result distribution use margin call meta distribution paul embrechts mcneil em brecht dia demarta mcneil show later advantage meta multivariate chapter methodology distribution allows easy construction ifm inference margin estimator simply latter case one need simultaneously optimize parameter former case take ifm step step approach put another way multivariate dis tribution imposes condition copula equal individual margin complicates numeric computation parameter force use mle turn computationally inten sive purpose exemplification perhaps useful look tail dependence measure bivariate copula case tail depen dence coefficient upper low dependence solve demarta mcneil note show page demarta mcneil increase decrease somewhat intuitive since ct converges gaussian copula go infinity another interest family copula gumbel hougaard family two previous family belong elliptical class particular one one parameter determines relationship variable case namely functional form cg exp log log two notable property copula easily notice param eter approach either one infinity clear gumbel hougaard equivalent product copula replace parameter opposite limit require complicate approach fact lim min intuitively one may understand parameter allow go infinity function converge minimum function different copula dependence minimum function copula interest prop erties fact upper bound copula aspreviouslystated thegumbel due upper low tail dependence useful property since per stylize fact metioned amongst others giacomini ha rdle embrechts dia negative return happen together often positive one bivariate case unfortunately gumbel hougaard copula low tail dependence useful purpose note however per tail dependence increase naturally since gumbel hougaard becomes product copula dependence therefore tail dependence many class copula however purpose copula right choice allow asymmetry return process rather heavier tail gaussian thus hougaard copula allows multitude relationship variable consideration via quasi correlation matrix chapter methodology chapter copula parameter fitting copula together margin may many parameter depend number dimension use one undertakes estimation copula margin parameter simultaneously implies heavy computational burden ease burden inference margin ifm method developed put simply framework allows copula thus cut compute time another advantage multiple argument optimization may unique solution sequential algorithm eliminates impractical problem assume margin already fit one proceed fitting copula parameter copula parameter fitting argmax problem involve copula parameter argument one hand imply copula like lihood function use copula likelihood function show do thus let look gaussian copula case respective copula probability density function pdf give follow ct cgauss chapter copula parameter fitting standard respectively joint univariate pdf quantile univariate standard distribution correspondingly standard joint respectively univariate gaussian pdf quantile univariate standard gaussian distribution look cgauss see maximization log likelihood log cgauss relevant time span respect involves consequently really straightforward algorithm construct transform calculate corr subsequently one copula parameter matrix use copula come copula thing become bit complicate due presence degree freedom parameter denominator optimization problem simple nevertheless approach two manner one joint optimization approach involves estimate quasi covariance matrix priori first approach definitely computationally intense involves si multaneously optimize number parameter number increase exponentially number variable joint investigation amount diagonal element matrix second approach sensible matrix may timated piece wise leaf relatively simple optimization degree freedom parameter compare fit different degree freedom one keep mind scalar practical purpose upper bound upper bound large distribution converges gaussian therefore make sense use copula large degree freedom might well save compute time use gaussian suggestion cycle different value find optimal one follow calculate matrix piece piece set maximum max set minimum min find maximizes likelihood use numerical algorithm argmax since previous chapter mention turn attention gumbel hougaard copula estimation parameter one parameter copula easy see analytical solution maximization problem subsequently becomes necessary optimization use numerical algorithm implementation bivariate case do xplore insist much mention issue margin treat separately ifm framework consequently three class discuss fitting pa rameters simply becomes matter estimate parameter argmax one argument computationally challenge author intuition copula yield meaningful result thus conclude proceed use particular tool chapter copula parameter fitting chapter data computational challenge dataset dataset investigation consists return eastern european cur rencies exchange rate euro source data data tream euro become official currency country euro area january back data may obtain via va riety method artificial ecu euro back data pub lished datastream bulk back data obtain use dollar exchange rate eastern european currency together usd eur ecu exchange rate data test actual eur eastern european exchange rate sign built return series compare actual return series overlap period period actual built exchange rate exist verify valid approach worth mention dataset contains trading day data consequently analysis may see analysis return consecu tive trading day rather analysis return equally space time period another way put time period least one currency show data eliminate analyze eastern european currency return one must also keep chapter data computational challenge country first peg first event second event bulgaria july pegged dm czech republic jan may peg basket abandon peg estonia june june pegged dm revaluation erm ii hungary february crawl peg peg abandon lithuania april february june peg usd peg euro erm ii latvia may erm ii poland january april crawl peg redenomination float romania july redenomination slovenia june january erm ii euro area slovakia october november march peg basket abandon erm ii revaluation eastern european country experience peg mind time span one look reference period worth point important part time span character ized depreciation currency see country experiment peg abandon one point another latter part period least currency prepare enter exchange rate mechanism country prepare adoption euro information important analysis peg require authority intervene defend erm ii mechanism presupposes percent variance band exchange rate data treatment gdp unemployment cpi country bulgaria czech republic estonia hungary lithuania latvia poland romania slovenia slovakia germany eastern european country economic development eastern european country large join european union implies point country question join erm ii subsequently euro area currency evolution since mid characterize rapid depreciation member group subsequent stabilization exchange rate stabiliza tion come either together form peg however always accompany improvement macroeconomic situation improvement economic situation since mid apparent far likely improvement responsible stable exchange rate introduction euro give uncertain nature future result would perhaps wise first look relationship use standard hard currency dataset first follow method analysis exemplify use eur gbp jpy sgd nok chf exchange rate return dollar data treatment order investigate relationship asset return take account empirical observation state previous chapter copula margin meta copula seem suitable chapter data computational challenge follow log return calculate change usd ex change rate six major currency use exemplification methodology input data copula analysis assume drawn distribution iid time vary volatility must first filter gi acomini ha rdle end common approach use order homogenize standardize volatility input data copula associate marginal distribution risk metric methodol ogy group return process assume consequently estimate thus decay factor shock volatility large faster decay purpose use parameter value suggest risk metric group due difficulty encounter obtain robust estimator garch model high one lag use equivalent garch indicate result obtain show second stage estimation procedure involves solve pa rameters marginal distribution copula window size observation use moment although dispute amount data point furthermore window size choice also depends dimension dataset investigate variable jointly large window size seem appropriate compensates large data treatment log return exchange rate versus usd dimension obviously trade concerned window size pertains amount data versus whether data window drawn distribution large window size indeed data increase take example meta copula ifm method follow order yield result timely manner alternative simultaneous estimation parameter prove extremely compu tationally intensive parameter degree freedom marginal distribution timated subsequently parameter copula quasi correlation matrix well degree freedom solve marginal distribution estimate degree freedom calculate ing widely available algorithm golden rule apply maximization implicit log likelihood derive distribution low upper bound set degree freedom respectively result obtain apply method show furthermore copula parameter correlation matrix chapter data computational challenge degree freedom term estimate independently start piecewise estimation one must use methodology outline de marta mcneil marginal distribution estimate degree freedom use kendall tau estimate pair variable possible estimate item sin point one may realize method may yield non positive semi definite matrix end method outline rousseeuw molenberghs use find positive semi definite matrix close data treatment one estimate way kendall tau minimize distance two matrix one obtains unique solution problem matrix compute example six exchange rate however result shall present result however present case eastern european exchange rate later thesis copula return usd eur gbp jpy sgd nok chf correlation matrix estimate one may procede estimate remain copula parameter do use golden rule algorithm apply implicit log likelihood derive copula function parameter calculate case five exchange rate euro czk eek huf pln skk result show result seem indicate strong dependence tail parameter approach low limit quite often certain time period method exemplify one move perform analysis core data try evaluate whether result chapter data computational challenge meaningful economic implication chapter result section aim present explain result estimation start introduce result univariate garch estimation result copula degree freedom also present together result quasi correlation matrix mention previously first step estimation process involves standardization data mean zero time invariant volatility order achieve one need assume residual follow time variant volatility process imply consequently time de pendent standard deviation residual solve use extract time invariant component result present observe tendency volatility cluster left column graph tendency disappears right column particularly one notice considerable decrease volatility eek skk exchange rate time fact former pegged time euro currency recently european exchange rate mechanism ii partially explains observation currency central bank actively intervenes market stabilize obviously less volatile one central bank take role past kroon peg first deutsche mark later euro hard maintain entry erm ii require cause stable currency vi vi chapter result euro another problem may affect volatility namely fact original data related dollar round four decimal lead mention error derive return data phenomenon persists begin dataset later part treatment data undertaken use actual return treat data treat data refers equation conversely one may look issue observe time dependent vari ance estimate per equation note eek time dependent volatility drop small value well diminish albeit zero skk volatility obvious country erm ii less volatile currency see period high volatility easily identifiable show sustain peak graph ex pected volatility prominent begin sample period correspond mid time eastern europe face prologued instability time dependent variance estimate equation nextstep copula parameter estimation state inthe previous chapter two stage process involve margin follow joint pa rameter fitting margin copula follow functional form distribution univariate margin degree freedom differ copula degree freedom data treat time dependent variance one infer instability degree freedom marginal distribution apparent reflect change shape distribution function toward away normal distribution rather change volatility low value degree freedom indicate departure chapter result normal distribution distribution mass tail graph indeed take indication much mass available extreme see degree freedom relatively small high value exception rather rule one conclude data present non normal behavior expect implies high proportion either large positive negative value mention previous chapter result two stage estimation process found close simultaneous estimation con sequently conclusion drawn look marginal distribution remain valid close would simultaneous optimization joint distribution undertaken marginal distribution degree freedom subsequently attention need turn copula degree freedom parameter specify earlier chapter optimization procedure set maximize copula imply maximum likelihood value degree freedom parameter interval low value parameter indicate acute tendency probability mass toward extreme value interest observe parameter value go low bound early part sample two factor contribute result first fact original data round well fact one may introduce extra copula degree freedom noise divide currency exchange rate dollar dollar exchange rate euro meant round may affect shape empirical observe distribution function return round mass extreme may overstate round exaggerates magnitude return mass around center distribution may also overstate due return ignore record zero due round second factor explain fact eastern european country mid time depreciation national currency vi vi one may call hard chapter result currency currency devaluate number joint incident extreme increase lead low copula degree freedom parameter finally inspection quasi correlation matrix call explain previous chapter correlation matrix per se rather mea sure rank correlation difference former lin ear relationship variable capture latter much broader measure co movement naturally since estimation element eq transform procedure make positive semidefinite matrix look element may yield much relevant information dependence structure copula estimate kernel density element rank coefficient transform covariance matrix currency pair avg std dev czk eek czk huf czk pln czk skk eek huf eek pln eek skk huf pln huf skk pln skk quasi please see fig result involve element matrix em pirical density question estimate use standard kernel density estimator matlab empirical distribution largely bi modal mean quite close zero would seem indicate particular clear tendency overall either positive negative association variable point fact currency either hit equally manner external shock respond dif ferently external stimulus unexpected result see history country involve point diversity exchange rate policy pursue early late however surprising country become stable currency behavior exchange rate market converge furthermore look one see sample average ap proaching zero also rather low variance go confirm mention observation general time span observe element matrix show clearly positive negative sign may behavior manifest local level order inspect behavior element time may useful havealookatfig possibility localize behavior meant two regime term relationship variable one might expect chapter result return scatter plot see two distinct mass scatter plot evidently case one may however remember look correla tion matrix rather transformation thereof furthermore interested co movement extreme due nature event frequency low weight compute kendall tau coefficient outweigh data point closer middle distribution furthermore evidence co movement indication weight tail multivariate distribution relatively low copula degree freedom coefficient noteworthy despite also relatively low value degree freedom coefficient margin particular copula parameter remains low especially would expect turbulent early mid implies infer co movement neither density quasi correlation matrix element scatter plot exists evidence co movement extreme increase copula margin degree freedom hand seem go together hand hand improve macroeco nomic outlook country question difficult say whether effect disentangle effect introduction euro chapter result chapter conclusion thesis implementation copula margin undertaken reason choose tool laid earlier chapter show decision line literature stylize fact data method thoroughly explain reader take implementation algorithm step standard exam ple use hard currency exchange rate use validity method underlined result aim thesis investigation relationship eastern european exchange rate data collect method apply main question ask whether troduction euro affect co movement country exchange rate result seem hint high volatility early follow period stabilization across board non normal marginal distribution variable question low copula degree freedom parameter value eventually crease albeit still low level chapter conclusion quasi correlation matrix element close zero consequently one say sure distribution variable consistent joint high positive joint negative behavior point low copula degree freedom parameter behavior seem ease later part sample previously mention parameter increase result also consistent improve economic situation country question work may carry purpose disentangle effect introduction euro effect improve economic situation bibliography asymmetric correlation equity portfolio jour nal financial economics demarta mcneil copula related copula department mathematics ethz www math ethz ch finance embrechts dia asymmetric correlation equity port folio journal financial economics embrechts dia dynamic copula model multivari ate high frequency data finance department mathematics ethz www math ethz ch finance giacomini risk management copula master thesis universit zu http lehre wiwi hu de professuren quantitativ statistik research dmb giacomini ardle value risk calculation time vary copula case work paper www case hu de giacomini ha rdle inhomogenous dependence model time vary copula wias work paper preprint group riskmetrics technical document new york mor gan reuters www riskmetrics com mill behaviour price new york national bureau economic research nelsen introduction copula sprnger verlag new york patton model assymetric exchange rate dependence ternational economic review vol bibliography paul embrechts mcneil model dependence copula application risk management department mathe matics ethz www math ethz ch finance rousseeuw molenberghs transformation non positive semidefinite correlation matrix communication statistic theory method code contains code use obtain estimate parameter copula previous chapter include stdio include math include conio include stdlib include iostream include fstream include stdlib include malloc include pdfcdfran define true define false define tiny define pi define im define im define im define imm im define ia define ia code define iq define iq define ir define ir define ntab define ndiv imm ntab define eps define rnmx eps define itmax define cgold define zep define tol itmax maximum allow number iteration cgold golden ratio zep small number protects try achieve fractional accuracy minimum happens exactly zero define gold define glimit define tiny gold default ratio successive interval magnify glimit maximum magnification allow parabolic fit step shift function use compute min funtion give parameter define shft define sign fabs fabs static double maxarg maxarg define fmax maxarg maxarg maxarg maxarg maxarg maxarg double miu sigma int po void reading one slice char file name double matrice int int int long seed void compute double matrice int int int long seed int factorial int int sign double double ro theta int int int double matrice void star double double matrice int int double gammaln double xx double vector mult double vect double vect int dim void siftdown double number int root int bottom void heapsort double number int array size double choose scalar double number int size double risk void ludcmp double int int indx double void lubksb double int int indx double void inverse compute int dim double matrice double inverse double determinant int size double matrice int choldc double matrice int double void scalar multiplication double matrice int double scalar void matrice add double matrice double matrice int void reset identity double matrice int void transform semiposdef double matrice int double double average int indice int double matrice double deviation double miu int indice int double matrice double double matrice double niu double int indice int double miu double sigma double double niu double inverse double matrice int indice int double det void transf price double matrice double int int double miu double sigma double niu vector double sqfn init double int prec double gammacf double double double gln double gammaser double double double gln double gammap double double double scdfn double double spdfn double double sqfn double double sqft init double double df int prec double betacf double double double double betai double double double code double double double double inverse double double df double double niu double inverse double matrice int int int indice double miu double sigma double det double int int double matrice double niu double inverse double miu double sigma double det double vector matrix multiplication int size double matrice double vector void vector matrix one way multiplication int size double matrice double vector double vector double ran long idum void random generator int double number long seed double transform double double ppnd double int ifault double ppchi double double double int ifault double transform double double void take one frame int size destination int position double source double destination void generator double matrice int int double niu double niu vector double miu double sigma double simulation vector long seed void matrix multiplication double double int double double matrice double niu int int indice double miu double sigma void mnbrak niu vector double ax double bx double cx double fa double fb double fc double matrice int int indice double miu double sigma double brent niu vector double ax double bx double cx double tol double xmin double matrice int int indice double miu double sigma void de garch int dim int monstra int number row void sort double number int left int right double function double check extreme value xisnan return dnan else xisposinf return else xisneginf return printf gammap return gammap else return gammap double inverse double double initapp qcur dx int prec initapp sqfn init prec prec return initapp iterate qcur initapp newton itmax dx scdfn qcur spdfn qcur qcur dx ab dx qcur newton eps return qcur iteration successful return initapp function use bracket local maximum function teh first row parameter necessarly ruturn bracket maximum value function second row parameter use function void mnbrak niu vector double ax double bx double cx double fa double fb double fc double matrice int int indice double miu double sigma double ulim fu dum code fa matrice ax indice miu sigma fb matrice bx indice miu sigma fb fa shft dum ax bx dum shft dum fb fa dum cx bx gold bx ax fc matrice cx indice miu sigma fb fc bx ax fb fc bx cx fb fa bx bx cx bx ax sign fmax fabs tiny ulim bx glimit cx bx bx cx fu matrice indice miu sigma fu fc ax bx bx fa fb fb fu return else fu fb cx fc fu return cx gold cx bx fu matrice indice miu sigma else cx ulim fu matrice indice miu sigma fu fc shft bx cx cx gold cx bx shft fb fc fu matrice indice miu sigma else ulim ulim cx ulim fu matrice indice miu sigma else cx gold cx bx fu matrice indice miu sigma shft ax bx cx shft fa fb fc fu function compute global maximum function necessarly find niu vector value maximise funtion parameter also function double brent niu vector double ax double bx double cx double tol double xmin double matrice int int indice double miu double sigma int iter double etemp fu fv fw fx tol tol xm double ax cx ax cx ax cx ax cx bx fw fv fx matrice indice miu sigma iter iter itmax iter xm tol tol tol fabs zep fabs xm tol xmin return fx fabs tol fx fv fx fw fabs code etemp fabs fabs etemp cgold xm else tol tol sign tol xm else cgold xm fabs tol sign tol fu matrice indice miu sigma fu fx else shft shft fv fw fx fu else else fu fw fv fw fw fu else fu fv fv fu printf many iteration brent xmin return fx function use bracket local maximum function first row parameter necessarly return bracket maximum value function second row parameter use function void mnbrak double ax double bx double cx double fa double fb double fc int int double matrice double inverse double miu double sigma double det double ulim fu dum printf mnbrak fa fb fc fa matrice ax inverse miu sigma det fb matrice bx inverse miu sigma det fb fa shft dum ax bx dum shft dum fb fa dum cx bx gold bx ax fc matrice cx inverse miu sigma det fb fc bx ax fb fc bx cx fb fa bx bx cx bx ax sign fmax fabs tiny ulim bx glimit cx bx bx cx fu matrice inverse miu sigma det fu fc ax bx bx fa fb fb fu return else fu fb cx code fc fu return cx gold cx bx fu matrice inverse miu sigma det else cx ulim fu matrice inverse miu sigma det fu fc shft bx cx cx gold cx bx shft fb fc fu matrice inverse miu sigma det else ulim ulim cx ulim fu matrice inverse miu sigma det else cx gold cx bx fu matrice inverse miu sigma det shft ax bx cx shft fa fb fc fu printf mnbrak ax bx cx printf mnbrak ax bx cx double brent double ax double bx double cx double tol double xmin int int dd double matrice double inverse double miu double sigma double det int iter double etemp fu fv fw fx tol tol xm double ax cx ax cx ax cx ax cx bx printf initializare brent ax bx cx fw fv fx dd matrice inverse miu sigma det printf dupa apel brent ax bx cx iter iter itmax iter xm tol tol tol fabs zep printf initializare brent ax bx cx fabs xm tol xmin printf brent ax bx cx xmin return fx fabs tol fx fv fx fw fabs etemp fabs fabs etemp cgold xm else tol tol sign tol xm else cgold xm fabs tol sign tol fu dd matrice inverse miu sigma det fu fx code else shft shft fv fw fx fu else else fu fw fv fw fw fu else fu fv fv fu printf many iteration brent xmin printf nin brent ax bx cx xmin return fx function call main program function read slice slice matrix give file computes algorith call compute function matrix give parameter fill value also dimension matrix give number row number coloumns reading procedure start reading one matrix succesivly reading line line rest file end new line add end already read matrix move row one position call compute function new obtain matrix void reading one slice char file name double matrice int int int long seed int float number calcul file fisier fisier fopen file name null printf open file name exit fscanf fisier number matrice number compute matrice seed fclose fisier funtion use compute multiplication transpose return value void matrix multiplication double double int int double sum sum sum sum code function make computation one matrix result write output file fisrt compute sigma miu compute vector niu maximization use function compute matrix inverse compute niu maximazing function run number generator one writes compute number output file last free memory start another computation another matrix void compute double matrice int int int long seed file fisier int define alloc compute average deviation double miu sigma miu double malloc sizeof double sigma double malloc sizeof double since miu sigma compute compute function fed modify matrix replace miu average matrice sigma deviation miu matrice define aloc memory niu vector double niu vector niu vector double malloc sizeof double compute niu value maximization double ax cx bx double fa fb fc double xmin ax bx fa matrice ax miu sigma fb matrice bx miu sigma fc matrice cx miu sigma mnbrak niu vector ax bx cx fa fb fc matrice miu sigma brent niu vector ax bx cx tol xmin matrice miu sigma niu vector xmin write niu file fisier fopen output file niu txt null printf open output file niu txt exit fprintf fisier niu vector fprintf fisier niu vector fprintf fisier fclose fisier compute alloc double double malloc sizeof double null code printf memory double malloc sizeof double null printf memory transf price matrice miu sigma niu vector double miu sigma miu double malloc sizeof double sigma double malloc sizeof double miu sigma define aloc memory double double malloc sizeof double null printf memory double malloc sizeof double null printf memory define compute star double double malloc sizeof double null printf memory double malloc sizeof double null printf memory star matrice compute define auxiliary define factor decomposition also compute determinant double double malloc sizeof double null printf memory double double malloc sizeof double null printf memory double malloc sizeof double null printf memory code transform semiposdef take star double det else det det use compute write output file matrix multiplication fisier fopen output file txt null printf open output file txt exit fprintf fisier fprintf fisier one free line matrix fprintf fisier fclose fisier compute inverse use inverse double inverse compute inverse compute double malloc sizeof double inverse compute null printf memory inverse compute double malloc sizeof double inverse compute null printf memory double inverse compute inverse compute double malloc sizeof double inverse compute null printf memory inverse compute double malloc sizeof double inverse compute null printf memory double aux aux double malloc sizeof double aux null printf memory code aux double malloc sizeof double aux null printf memory aux inverse compute aux inverse compute compute inverse double sum int sum sum inverse compute inverse compute inverse compute sum define niu compute maximization double niu ax bx fa ax inverse compute miu sigma det fb bx inverse compute miu sigma det fc cx inverse compute miu sigma det printf mnbrak fa fb fc printf initial ax bx cx niu mnbrak ax bx cx fa fb fc inverse compute miu sigma det printf dupa nmbrak ax bx cx niu brent ax bx cx tol niu inverse compute miu sigma det printf dupa brent ax bx cx niu write niu output file fisier fopen output file txt null printf open output file txt exit fprintf fisier niu fprintf fisier niu fprintf fisier simulated vector fclose fisier simulation part double simulation vector simulation vector double malloc sizeof double printf compute one matrix finish enter generator generator niu niu vector miu sigma simulation vector seed free miu free sigma free miu free sigma free niu vector free free free code free free free simulation vector free inverse compute free aux free inverse compute function compute sign one real number int sign double int result result else result else result return result use compute matrix double ro theta int int int double matrice double result int double sume diagonal equal return sume sume sign matrice matrice matrice matrice factorial compute inside formula result sume return result use compute matrix void star double double matrice int int int sin pi ro theta matrice logarithm gamma function xx use int compute niu value double gammaln double xx double cof double fact result temp ser int check dllislessorequal xx xisneginf xx return dnan xisposinf xx return xx dllisequal xx return dllisequal xx return dlllog sqrtpi computation xx use gamma gamma xx result else use approximation directly xx result dlllog xx temp temp dlllog temp ser code ser cof result temp dlllog fact ser return result function multiply two vector double vector mult double vect double vect int dim double result int dim printf vect vect dim result result vect vect printf vector mul result return result use heapsort void siftdown double number int root int bottom int do maxchild double temp do root bottom do root bottom maxchild root else number root number root maxchild root else maxchild root number root number maxchild temp number root number root number maxchild number maxchild temp root maxchild else do function sort increase order vector number void heapsort double number int array size int double temp array size siftdown number array size array size temp number number number number temp siftdown number choses scalar risk small double choose scalar double number int size double risk double result result risk size return number int result function obtain lu decomposition matrix use compute inverse matrix compute inverse void ludcmp double int int indx double int imax double big dum sum temp code double vv vv double malloc sizeof double big temp fabs big big temp big printf singular matrix routine ludcmp vv big sum sum sum big sum sum sum dum vv fabs sum big big dum imax imax dum imax imax dum vv imax vv indx imax tiny dum dum free vv function solves ax system equation use compute inverse matrix void lubksb double int int indx double int ii ip double sum ip indx sum ip ip ii ii sum else sum ii sum sum sum sum function compute inverse matrix compute inverse obtain inverse void inverse compute int dim double matrice double inverse double col int indx indx int malloc dim sizeof int col double malloc dim sizeof double ludcmp matrice dim indx decompose matrix dim find inverse column dim col col code lubksb matrice dim indx col dim inverse col free indx free col function compute determinant mtrix use moment program double determinant int size double matrice double int indx indx int malloc size sizeof int ludcmp matrice size indx size matrice free indx return function compute decomposition matrix use obtain matrix int choldc double matrice int double give positive de nite symmetric matrix routine construct cholesky decomposition lt input upper triangle need give modi ed cholesky factor return low triangle except diagonal element return void nrerror char error text int result double sum result sum matrice sum matrice matrice sum round error positive de nite printf choldc fail result sqrt sum else matrice sum return result function compute multiplication matrix scalar return new matrix matrix give parameter void scalar multiplication double matrice int double scalar int matrice matrice scalar funtion compute sum matrix result obtain first matrix give parameter void matrice add double matrice double matrice int int matrice matrice matrice funtion reobtain identity matrix void reset identity double matrice int int matrice code else matrice function transform metix positive definite one us test cholesky decomposition mtrix positive definite decompose cholesky method void transform semiposdef double matrice int double double identity int identity double malloc sizeof double identity null printf memory identity double malloc sizeof double identity null printf memory double lambda result delta int test redundanta reset identity identity result choldc matrice lambda result test redundanta scalar multiplication matrice lambda scalar multiplication identity lambda matrice add matrice identity reset identity identity lambda lambda result choldc matrice test redundanta funtion use compute miu average coloumn matrix price double average int indice int double matrice int double result result result matrice indice return result function use compute sigma deviation matrix price return sigma square since use double deviation double miu int indice int double matrice double result int result result pow matrice indice miu result result return result function compute give niu indice coloumn representive niu value compute range return small value since need compute value maximum obtain range double double matrice double niu int int indice double miu double sigma int double sum niu niu sum else sum matrice niu matrice indice indice miu sigma return sum code funtion use statistic function double double matrice double niu double int indice int double miu double sigma double result miu sigma miu miu indice sigma sigma indice result gammaln niu gammaln niu log pi niu sigma result result niu log miu miu niu sigma return result statistic funtion use compute niu double double niu double inverse double matrice int indice int double det double result double vector vector double malloc sizeof double int vector inverse matrice indice niu printf vector result gammaln niu gammaln niu log pi niu log det printf ngammaln result aici se fute meciul float info vector matrix multiplication inverse vector result result log vector matrix multiplication inverse vector niu niu printf ninfo info free vector return result funtion obtain matrix matix price void transf price double matrice double int int double miu double sigma double niu vector int printf sqrt sigma matrice miu sqrt sigma niu vector initial approximation quantile prec return result precise double sqfn init double int prec double xp prec follow answer precise constant approximation check special value xisnan xisneginf xisposinf return dnan dlliszero return dinf dllisequal return dinf dllislessorequal dllisgreaterorequal return dnan dllisequal return prec follow answer approximation approximation code sqrt dlllog xp xp xp return xp double gammacf double double double gln int double del check dlliszero return dllisgreater dnan dllislessorequal return dnan computation gln gammaln dblmin itmax ab dblmin dblmin ab dblmin dblmin del del ab del eps return dllexp dlllog gln return dnan double gammaser double double double gln int double sum del ap check dlliszero return dllislessorequal return dnan init gln gammaln ap del sum computation itmax ap del ap sum del ab del ab sum eps return sum dllexp dlllog gln dllisgreaterorequal return dinf else return dnan double gammap double double double gln dllislessorequal xisnan return dnan xisposinf return dllisless xisneginf return code return gammaser gln else return gammacf gln double scdfn double check extreme value xisnan return dnan else xisposinf return else xisneginf return return gammap else return gammap normal pdf double spdfn double return dllexp sqrtpi sqrt normal quantile via newton method double sqfn double double initapp qcur dx int prec initapp sqfn init prec prec return initapp iterate qcur initapp newton itmax dx scdfn qcur spdfn qcur qcur dx ab dx qcur newton eps return qcur iteration successful return initapp student distribution inversion initial approximation prec return result precise double sqft init double double df int prec double re int dummy prec check special value xisnan xisneginf xisposinf xisnan df dllislessorequal df xisneginf df printf ramura dnan return dnan dlliszero printf ramura dinf return dinf dllisequal printf ramura dinf return dinf dllislessorequal dllisgreaterorequal printf ramura dnan return dnan dllisequal return xisposinf df printf ramura sqfn code return sqfn prec dllisequal df printf ramura tan pi return tan pi dllisequal df printf ramura sqrt sqrt return sqrt sqrt sqfn init dummy df df df re sqrt df dllexp df re re printf final re return re double betacf double double double double aa del qab qam qap int qab qap qam qab qap ab dblmin dblmin itmax aa qam aa ab dblmin dblmin aa ab dblmin dblmin aa qab qap aa ab dblmin dblmin aa ab dblmin dblmin del del ab del eps return return dnan double betai double double double double bt check dllisless dllisgreater xisnan xisposinf xisneginf return dnan dlliszero dllisequal bt else bt dllexp gammaln gammaln gammaln dlllog dlllog return bt betacf else return bt betacf code function use thransforming matrix price lot double double double checkv extreme value xisnan xisnan dllislessorequal xisneginf return dnan else xisposinf return else xisneginf return else xisposinf return scdfn return betai else return betai inverse function double inverse double double df double initapp qcur dx int prec printf initapp sqft init df prec printf initapp prec printf initapp return initapp iterate qcur initapp newton itmax dx qcur df qcur df qcur dx ab dx qcur newton eps printf qcur return qcur iteration successful printf initapp return initapp function use compute give niu double double niu double inverse double matrice int int int indice double miu double sigma double det double suma double aux int suma suma matrice niu inverse matrice indice niu miu sigma aux niu inverse matrice indice det suma return aux function use obtain niu value function obtaines maximum compute sum funtions row test point extreme obtain range double int int double matrice double niu double inverse double miu double sigma double det int double result niu niu result printf nniu niu result else code result result niu inverse matrice miu sigma det printf result return result funtion use function compute tp product return scalar computes first first matrix multiplication matrix call vector multiplication double vector matrix multiplication int size double matrice double vector double aux result aux double malloc size sizeof double int size aux size aux aux matrice vector result vector mult aux vector size free aux return result function compute multiplication matrix vector return value vector use random generator function void vector matrix one way multiplication int size double matrice double vector double vector int size vector size vector vector matrice vector function generate random number use seed give parameter double ran long idum int long static long idum static long iy static long iv ntab double temp idum idum idum else idum idum idum idum ntab idum iq idum ia idum iq ir idum idum im ntab iv idum iy iv idum iq idum ia idum iq ir idum idum im idum iq idum ia idum iq ir idum idum im iy ndiv iy iv idum iv idum iy iy imm temp iy rnmx return rnmx else return temp code function generate ramndom number use seed use geneting ramndom number simulation part void random generator int double number long seed int long idum printf seed number ran seed use random generator transform number generate sequence number fulfill require distribution double transform double double xp constant approximation check special value dllisequal return approximation sqrt dlllog xp xp xp return xp auxiliary function chi inverse double ppnd double int ifault system generate local double ret val local variable static double algorithm appl statist vol produce normal deviate correspond give low tail area accurate part hash sum sum mantissa coefficient include use check transcription coefficient close hash sum ab coefficient close hash sum cd coefficient near hash sum ifault ab ret val return ret val else else code ifault ret val return ret val sqrt log ret val else ret val ret val ret val return ret val return ret val double ppchi double double double int ifault static double aa static double six static double static double static double static double static double static double static double static double static double static double static double static double static double static double static double static double static double static double static double static double static double pmin static double static double static double static double static double static double static double static double static double static double static double pmax static double static double static double static double static double static double static double static double code static double static double zero static double half static double one static double two static double three double ret val define pow dd pow local variable extern double ppnd static double static int static double static double ch xx static int algorithm appl statist vol evaluate percentage point chi square probability distribution function must lie range must positive must supply equal ln gamma incorporates suggest change vol pp eliminate need limited range though limit remove routine ifault return result probably accurate machine allow auxiliary routine require ppnd gammad test argument initialise ret val one ifault pmin pmax return ret val ifault zero return ret val ifault xx half xx one log goto xx exp xx aa one xx ch pow dd ch goto goto goto ch log one ch one ch ch ch ch ch half two ch ch three ch ch one exp half ch aa ch one ab goto goto call algorithm note test could use alternative ppnd start approximation use wilson hilferty estimate compute rd power sqrt one ch start approximation tend code ch six ch two log one log half ch call algorithm calculation seven term taylor series ch half ch gammap xx goto ifault return ret val exp xx aa log ch ch half ch one half ch one ab goto ifault ret val ch return ret val funtion transfor arbitrary number generate random generator number use computation simluation part double transform double double double int ifault check special value xisnan xisneginf xisposinf xisnan dllislessorequal xisneginf xisposinf return dnan dlliszero return dllisequal return dinf dllislessorequal dllisgreaterorequal return dnan gammaln return ppchi ifault function substract small part long sequence random number generate void take one frame int size destination int position double source double destination int size destination destination source position void quicksort double number int array size sort number array size void sort double number int left int right double pivot hold hold hold left hold right pivot number left left right code number right pivot left right right left right number left number right left number left pivot left right left left right number right number left right number left pivot pivot left left hold right hold left pivot sort number left pivot right pivot sort number pivot right main simulation function void generator double matrice int int double niu double niu vector double miu double sigma double simulation vector long seed file fisier double big big double malloc sizeof double double double malloc sizeof double int double double double malloc sizeof double double malloc sizeof double double double malloc sizeof double double sim sum vector sim sum vector double malloc sizeof double sim sum vector generate number random generator big seed fisier fopen output file quantiles txt null printf open output file quantiles txt exit take one frame big transform transform niu vector matrix one way multiplication matrice sqrt niu sqrt niu simulation vector inverse niu vector sqrt sigma miu sqrt sigma po miu po sim sum vector simulation vector fprintf fisier sim sum vector fprintf fisier quicksort sim sum vector printf sim sum vector fprintf fisier sim sum vector int sim sum vector int sim sum vector int code sim sum vector sim sum vector sim sum vector sim sum vector sim sum vector fclose fisier free big free sim sum vector free free free free void de garch int dim int monstra int number row double matrice float number file fisier de garching part alloc space matrice data matrix matrice double malloc number row sizeof double matrice null printf memory int number row matrice double malloc dim sizeof double matrice null printf memory fisier fopen data project txt null printf open data project txt exit data matrix read feof fisier int number row int dim fscanf fisier number matrice number fclose fisier printf terminat citire size initial sample de garching double sum double miu monstra sigma monstra miu monstra double malloc dim sizeof double sigma monstra double malloc dim sizeof double int dim sum int monstra sum sum matrice miu monstra sum monstra dim int monstra miu miu monstra dim int monstra number row sum int sum sum matrice miu sum printf terminat de calculat miu code write miu file fisier fopen output miu txt null printf open output miu txt exit number row dim fprintf fisier miu fprintf fisier fclose fisier compute sigma double lambda dim sum int monstra sum sum exp lambda monstra matrice miu matrice miu sigma monstra exp lambda sum dim int monstra sigma sigma monstra dim int monstra number row sum int sum sum exp lambda matrice miu matrice miu sigma exp lambda sum printf terminat calculat sigma write sigma file fisier fopen output sigma txt null printf open output sigma txt exit number row dim fprintf fisier sigma fprintf fisier fclose fisier write new file fisier fopen output garch txt null printf open output garch txt exit number row dim fprintf fisier matrice miu sqrt sigma fprintf fisier fclose fisier matrice free matrice free miu monstra free sigma monstra void main void int dim number column code int dim int long seed float number int monstra int number row file fisier fisier fopen data project txt null printf open data project txt exit int feof fisier int dim fscanf fisier number number row fclose fisier alloc space miu vector avgs de garching miu double malloc number row sizeof double miu null printf memory number row miu double malloc dim sizeof double miu null printf memory alloc space sigma sigma double malloc number row sizeof double sigma null printf memory number row sigma double malloc dim sizeof double sigma null printf memory de garch dim monstra number row reading miu sigma file fisier fopen output miu txt null printf open output garch txt exit number row int dim fscanf fisier number miu number fclose fisier fisier fopen output sigma txt null printf open output garch txt exit number row int dim fscanf fisier number sigma number code fclose fisier double matrice matrice modificata printf terminat degauch alloc space matrice data matrix matrice modificata double malloc number row sizeof double matrice null printf memory number row matrice modificata double malloc dim sizeof double matrice modificata null printf memory fisier fopen output garch txt null printf open output garch txt exit number row int dim fscanf fisier number matrice modificata number printf citit noua matrice fclose fisier po dim printf intram number row po number row printf begining alloc space matrice data matrix matrice double malloc dim sizeof double matrice null printf memory int dim matrice double malloc dim sizeof double matrice null printf memory po dim po int dim matrice po dim matrice modificata compute matrice dim dim seed po free matrice printf try free matrice printing check purpose